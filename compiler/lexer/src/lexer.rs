use crate::LexerError;

type LexerResult<T> = Result<T, LexerError>;


// Characters supported by the lexer.
#[derive(Debug)]
pub struct Chars {
}

impl Chars {
    // Creates a new Chars object.
    fn new() -> Self {
        Chars {}
    }
}


// The lexer structure.
#[derive(Debug)]
pub struct Lexer {
    code: Vec<char>,
    cursor: usize,
    row: usize,
    column: usize,
    indentation: u32,
    allowed_chars: Chars,
}

// Structure for token generated by the lexer.
#[derive(Debug)]
pub struct Token {
    string: String,
    row: usize,
    column: usize,
}

impl Lexer {
    // Creates a new Lexer object.
    pub fn new(code: String) -> Self {
        Self {
            code: code.chars().collect(),
            cursor: 0,
            row: 0, column: 0, indentation: 0, allowed_chars: Chars::new() }
    }

    // Eats a character if available.
    pub fn eat_char(&mut self) -> Option<char> {
        self.cursor += 1;

        if self.code.len() >= self.cursor {
            return Some(self.code[self.cursor]);
        }

        None
    }

    // Tokenizes the code.
    pub fn lex(&mut self) -> LexerResult<Vec<Token>> {
        // Tokens
        let mut tokens = Vec::new();

        // Consume a character.
        let ch = self.eat_char();

        // Iteratively associates each token.
        loop {
            match ch {
                // ...
                _ => break,
            }
        }

        Ok(tokens)
    }
}

