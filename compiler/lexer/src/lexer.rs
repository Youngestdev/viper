use crate::LexerError;

type LexerResult<T> = Result<T, LexerError>;

// Characters supported by the lexer.
#[derive(Debug)]
pub struct Chars {}

impl Chars {
    // Creates a new Chars object.
    fn new() -> Self {
        Chars {}
    }
}

// The lexer structure.
#[derive(Debug)]
pub struct Lexer {
    code: Vec<char>,
    cursor: usize,
    row: usize,
    column: usize,
    indentation: u32,
    allowed_chars: Chars,
}

// Structure for token generated by the lexer.
#[derive(Debug)]
pub struct Token {
    string: String,
    row: usize,
    column: usize,
}

impl Token {
    pub fn new(string: String, row: usize, column: usize) -> Self {
        Self {
            string,
            row,
            column,
        }
    }
}

impl Lexer {
    // Creates a new Lexer object.
    pub fn new(code: String) -> Self {
        Self {
            code: code.chars().collect(),
            cursor: 0,
            row: 0,
            column: 0,
            indentation: 0,
            allowed_chars: Chars::new(),
        }
    }

    // Eats a character if available.
    pub fn eat_char(&mut self) -> Option<char> {
        self.cursor += 1;

        if self.code.len() >= self.cursor {
            return Some(self.code[self.cursor]);
        }

        None
    }

    // Tokenizes the code.
    pub fn lex(&mut self) -> LexerResult<Vec<Token>> {
        // Tokens
        let mut tokens = Vec::new();

        // Consume a character.
        let ch = self.eat_char();

        // Iteratively associates each token.
        loop {
            let Self { row, column, .. } = self;
            // let mut token: LexerResult<Token>;

            // identifier, digits, spaces (in/dedentations),
            if let Some(ch) = ch {
                let token = match ch {
                    'a' => self.lex_identifier(),
                    _ => {
                        return Err(LexerError::new(
                            format!("Unexpected token: '{}'!", ch),
                            *row,
                            *column,
                        ))
                    }
                };
            } else {
                return Err(LexerError::new(
                    format!("Unexpected token: '{}'!", ch.unwrap()),
                    *row,
                    *column,
                ));
            }
        }

        Ok(tokens)
    }

    //
    pub fn lex_identifier(&mut self) -> LexerResult<Token> {
        Ok(Token::new(String::new(), self.row, self.column))
    }
}
